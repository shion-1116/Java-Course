package org.example;

public interface Eating {

  void eat();

  void displayFood();
}
  /*  // 食すことができることを決めるルールブック
  package org.example;
    意味：「org.example」というパッケージ（＝Javaのフォルダ分け）にこのインターフェースが属していることを示している。
    ポイント：パッケージを使うことで、クラスやインターフェースを整理しやすくなる
            大規模開発や他人のライブラリと重複しないようにするために、パッケージ名を付けるのが一般的

  public interface Eating
    意味：「public」というアクセス修飾子を使い、どこからでもアクセスできるインターフェースとしてEatingを宣言してる
    ポイント：publicを付けることで、他のパッケージからもこのインターフェースを実装したり利用したりできる
            インターフェース自体は実装を持たず、「これを実装するクラスは、必ずこのメソッドを持ってね」という約束だけを決めている

  void eat();
  void displayFood();
    意味：「食べる」行為を抽象化し、eat()とdisplayFood()を定義。
          void eat();は「食べる動作を表すメソッド」で、戻り値は無し（void）。
          void displayFood();は「食べ物の情報を表示するメソッド」で、こちらも戻り値は無い
    ポイント：どちらも「実装は持たず、メソッド名と引数、戻り値の型だけを定義」している
            これを実装するクラスは、必ずこの2つのメソッドを実装しなければならない
  ①eat()
    → 「この食べ物をどうやって食べるか？」の動作を表現するメソッド
    例：焼いて食べる、刺身で食べる、すき焼きで食べるなど、食べる方法や実際のアクションを見せる
  ②displayFood()
    → 「この食べ物は何か？」を画面に表示するだけのメソッド
    例：牛肉（北海道産）やサーモン（オホーツク海）など、食べ物の種類や産地などの情報を見せる

  */

/*
最初は動画と同じようにやっていたのだが、理解が出来ずAIに頼ったらこのようになった　↑
下記は、動画と同じようにやろうとした奴
public interface Eating {
  public String eat(String eat);
}
 */

  /*
  23:00～　Foodは、中身を作ることができない
  中身を定義しようとすると、エラーが出てきてしまう
  　→　エラー内容は「インターフェースの抽象メソッドに本体を書くことはできません」と出てくるので、デフォルトにしないといけない
  定義 = 中身の詳細を書いてはいけない
  24:10～　「abstract class(=抽象クラス)」や「interface」
  　→　概念を定義づけするためのやつら（あくまでこれらは、概念的な存在）
  */